from dataclasses import dataclass, field
from typing import Dict, Any

__all__ = ["Task"]


@dataclass
class Task:
    """
    Represents a task that the agent should attempt to complete.
    
    Tasks in the SIMA architecture are generated by the TaskSetter and provide
    both a natural language description of what to accomplish and metadata
    for evaluation and learning.
    
    The estimated_reward serves as an initial guess that helps the TaskSetter
    propose appropriately challenging tasks - not too easy (already mastered)
    or impossibly hard (agent can't learn from failure).
    """
    id: str
    description: str  # Natural language description, e.g. "Reach the glowing portal"
    estimated_reward: float  # Initial reward estimate from TaskSetter
    max_steps: int  # Maximum number of environment steps allowed
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate task data after initialization."""
        if not self.id.strip():
            raise ValueError("Task ID cannot be empty")
        if not self.description.strip():
            raise ValueError("Task description cannot be empty")
        if self.max_steps <= 0:
            raise ValueError("max_steps must be positive")

    @property
    def difficulty_estimate(self) -> str:
        """
        Get a rough difficulty estimate based on estimated reward.
        
        Returns:
            Difficulty string ("easy", "medium", "hard")
        """
        if self.estimated_reward >= 8.0:
            return "easy"
        elif self.estimated_reward >= 4.0:
            return "medium"
        else:
            return "hard"

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert task to dictionary for serialization.
        
        Returns:
            Dictionary representation of the task
        """
        return {
            "id": self.id,
            "description": self.description,
            "estimated_reward": self.estimated_reward,
            "max_steps": self.max_steps,
            "metadata": self.metadata
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Task":
        """
        Create task from dictionary representation.
        
        Args:
            data: Dictionary containing task data
            
        Returns:
            Task object
        """
        return cls(
            id=data["id"],
            description=data["description"],
            estimated_reward=data["estimated_reward"],
            max_steps=data["max_steps"],
            metadata=data.get("metadata", {})
        )
